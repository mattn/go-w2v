// Code generated by golex. DO NOT EDIT.

package main

import (
	"bufio"
	"errors"
	"fmt"
	"go/token"
	"strings"
	"unicode"

	"github.com/cznic/golex/lex"
	"github.com/mattn/komachi"
)

type lexer struct {
	*lex.Lexer
	empty   bool
	current byte
	err     error
	model   w2v.Model
	vector  *w2v.Vector
}

func clazz(r rune) int {
	if r < 0 || unicode.IsSpace(r) || r == '+' || r == '-' {
		return int(r)
	}
	return 0x80
}

func newLexer(model w2v.Model, src *bufio.Reader) *lexer {
	f := token.NewFileSet().AddFile("w2v", -1, 1<<31-1)
	lx, err := lex.New(f, bufio.NewReader(src), lex.RuneClass(clazz))
	if err != nil {
		panic(err)
	}
	return &lexer{Lexer: lx, model: model}
}

func (l *lexer) Error(e string) {
	l.err = errors.New(e)
}

func (l *lexer) Lex(lval *yySymType) int {
	c := l.Enter()

yystate0:
	yyrule := -1
	_ = yyrule
	c = l.Rule0()

	goto yystart1

	goto yystate0 // silence unused label error
	goto yyAction // silence unused label error
yyAction:
	switch yyrule {
	case 1:
		goto yyrule1
	case 2:
		goto yyrule2
	}
	goto yystate1 // silence unused label error
yystate1:
	c = l.Next()
yystart1:
	switch {
	default:
		goto yyabort
	case c == '\t' || c == '\n' || c == '\r' || c == ' ':
		goto yystate2
	case c == '\u0080':
		goto yystate3
	}

yystate2:
	c = l.Next()
	yyrule = 1
	l.Mark()
	switch {
	default:
		goto yyrule1
	case c == '\t' || c == '\n' || c == '\r' || c == ' ':
		goto yystate2
	}

yystate3:
	c = l.Next()
	yyrule = 2
	l.Mark()
	switch {
	default:
		goto yyrule2
	case c == '\u0080':
		goto yystate3
	}

yyrule1: // [ \t\r\n]+

	goto yystate0
yyrule2: // {word}
	{

		s := strings.TrimSpace(string(l.TokenBytes(nil)))
		if s != "" {
			if lval.value = l.model.Find(s); lval.value == nil {
				l.Error(fmt.Sprintf("%q not found", s))
				lval = nil
			}
			return VALUE
		}
		goto yystate0
	}
	panic("unreachable")

	goto yyabort // silence unused label error

yyabort: // no lexem recognized
	if c, ok := l.Abort(); ok {
		return int(c)
	}
	goto yyAction
}
